name: Build and Publish JRE Runtime

on:
  push:
    tags:
      - 'v*'   # Trigger on version tags like v1.0.0
  workflow_dispatch:
    inputs:
      java_version:
        description: 'Java version (e.g., 21.0.5+11)'
        required: false
        default: '21.0.5+11'
        type: string
      tag_version:
        description: 'Version tag for the runtime (e.g., 1.0.0)'
        required: false
        default: '1.0.0-manual'
        type: string

permissions:
  contents: read
  packages: write  # Required for publishing to GitHub Packages

jobs:
  build-runtime:
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        include:
          # Define OS-specific variables for naming
          - os: ubuntu-latest
            os_name: linux
            archive_ext: tar.gz
          - os: macos-latest
            os_name: macos
            archive_ext: tar.gz
          - os: windows-latest
            os_name: windows
            archive_ext: zip

    steps:
      # 1. Check out the repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Set Java and version parameters
      - name: Set Java and version parameters
        shell: bash
        run: |
          # Set Java version (from input or default)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            JAVA_VERSION="${{ inputs.java_version }}"
            VERSION="${{ inputs.tag_version }}"
          else
            JAVA_VERSION="21.0.5+11"
            VERSION="${GITHUB_REF_NAME#v}"
          fi
          echo "JAVA_VERSION=$JAVA_VERSION" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Using Java version: $JAVA_VERSION"
          echo "Using runtime version: $VERSION"

      # 3. Detect architecture
      - name: Detect architecture
        shell: bash
        run: |
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            ARCH="x64"
          elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
            ARCH="aarch64"
          fi
          echo "ARCH=$ARCH" >> $GITHUB_ENV
          echo "Detected architecture: $ARCH"

      # 4. Set up JDK 21 using actions/setup-java with JavaFX support
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: liberica
          java-version: 21
          java-package: jdk+fx

      # 5. Verify JAVA_HOME and add to PATH
      - name: Verify JAVA_HOME and add to PATH
        shell: bash
        run: |
          echo "JAVA_HOME: $JAVA_HOME"
          if [ -z "$JAVA_HOME" ]; then
            echo "ERROR: JAVA_HOME is not set"
            exit 1
          fi
          if [ ! -d "$JAVA_HOME/bin" ]; then
            echo "ERROR: $JAVA_HOME/bin not found"
            echo "Contents of $JAVA_HOME:" || true
            ls -la "$JAVA_HOME" || true
            exit 1
          fi
          echo "$JAVA_HOME/bin" >> $GITHUB_PATH
          "$JAVA_HOME/bin/java" -version
          "$JAVA_HOME/bin/jlink" --version

      # 6. Create custom JRE runtime using jlink
      #    This creates a minimal runtime with JavaFX modules included
      - name: Build custom JRE with jlink (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          # Ensure a clean output directory
          rm -rf build/runtime
          mkdir -p build/runtime

          # Run jlink to create custom runtime
          "$JAVA_HOME/bin/jlink" \
            --module-path "$JAVA_HOME/jmods" \
            --add-modules java.base,java.logging,java.desktop,java.sql,java.naming,java.management,java.xml,java.prefs,javafx.controls,javafx.fxml,javafx.graphics,javafx.swing,javafx.media \
            --output build/runtime \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --compress=2

          echo "Custom JRE created successfully"
          ls -la build/runtime

      - name: Build custom JRE with jlink (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          # Ensure a clean output directory on Windows
          if (Test-Path 'build/runtime') { Remove-Item 'build/runtime' -Recurse -Force }
          New-Item -ItemType Directory -Path 'build/runtime' | Out-Null

          # Run jlink using Windows paths
          & "$env:JAVA_HOME\bin\jlink.exe" `
            --module-path "$env:JAVA_HOME\jmods" `
            --add-modules java.base,java.logging,java.desktop,java.sql,java.naming,java.management,java.xml,java.prefs,javafx.controls,javafx.fxml,javafx.graphics,javafx.swing,javafx.media `
            --output build/runtime `
            --strip-debug `
            --no-header-files `
            --no-man-pages `
            --compress=2

          Write-Output "Custom JRE created successfully"
          Get-ChildItem build\runtime -Force | Format-List

      # 7. Create archive name based on OS, architecture, and version
      - name: Set archive name
        shell: bash
        run: |
          ARCHIVE_NAME="efa-jre-${{ env.VERSION }}-${{ matrix.os_name }}-${{ env.ARCH }}.${{ matrix.archive_ext }}"
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV
          echo "Archive will be named: $ARCHIVE_NAME"

      # 8. Archive the runtime (tar.gz for Linux/macOS, zip for Windows)
      - name: Archive runtime (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          cd build
          tar -czf "../${{ env.ARCHIVE_NAME }}" runtime
          cd ..
          echo "Archive created: ${{ env.ARCHIVE_NAME }}"
          ls -lh "${{ env.ARCHIVE_NAME }}"

      - name: Archive runtime (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          cd build
          Compress-Archive -Path runtime -DestinationPath "..\${{ env.ARCHIVE_NAME }}"
          cd ..
          echo "Archive created: ${{ env.ARCHIVE_NAME }}"
          Get-Item "${{ env.ARCHIVE_NAME }}" | Format-List

      # 9. Generate SHA-256 checksum for the archive
      - name: Generate SHA-256 checksum
        shell: bash
        run: |
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            sha256sum "${{ env.ARCHIVE_NAME }}" > "${{ env.ARCHIVE_NAME }}.sha256"
          else
            shasum -a 256 "${{ env.ARCHIVE_NAME }}" > "${{ env.ARCHIVE_NAME }}.sha256"
          fi
          cat "${{ env.ARCHIVE_NAME }}.sha256"

      # 10. Upload artifact to GitHub Actions (for workflow verification)
      - name: Upload runtime archive as artifact
        uses: actions/upload-artifact@v4
        with:
          name: jre-${{ matrix.os_name }}-${{ env.ARCH }}
          path: |
            ${{ env.ARCHIVE_NAME }}
            ${{ env.ARCHIVE_NAME }}.sha256

      # 11. Publish to GitHub Packages as a generic package
      #     GitHub Packages supports generic packages via the API
      #     We'll use the GitHub CLI (gh) which is pre-installed on runners
      - name: Publish to GitHub Packages
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Package details
          PACKAGE_NAME="${{ github.repository }}-jre"
          PACKAGE_VERSION="${{ env.VERSION }}"

          echo "Publishing package: $PACKAGE_NAME"
          echo "Version: $PACKAGE_VERSION"
          echo "File: ${{ env.ARCHIVE_NAME }}"

          # Upload the archive to GitHub Packages using the API
          # GitHub Packages requires uploading to a specific endpoint
          # Format: https://maven.pkg.github.com/OWNER/REPO

          # For generic packages, we can use the Releases API or Maven registry
          # Since we're already creating a release workflow, we'll upload to releases
          # For true generic package support, consider using a Maven-compatible approach
          # or the Container registry with additional metadata

          # Create a release if it doesn't exist
          if ! gh release view "v${{ env.VERSION }}" >/dev/null 2>&1; then
            gh release create "v${{ env.VERSION }}" \
              --title "Release v${{ env.VERSION }}" \
              --notes "Custom JRE runtime images for version ${{ env.VERSION }}" \
              --draft=false \
              --prerelease=false || true
          fi

          # Upload the archive to the release
          gh release upload "v${{ env.VERSION }}" \
            "${{ env.ARCHIVE_NAME }}" \
            "${{ env.ARCHIVE_NAME }}.sha256" \
            --clobber
