name: Build and Publish JRE Runtime

on:
  push:
    tags:
      - 'v*'   # Trigger on version tags like v1.0.0
  workflow_dispatch:
    inputs:
      java_version:
        description: 'Java version (e.g., 21.0.5+11)'
        required: false
        default: '21.0.5+11'
        type: string
      tag_version:
        description: 'Version tag for the runtime (e.g., 1.0.0)'
        required: false
        default: '1.0.0-manual'
        type: string

permissions:
  contents: read
  packages: write  # Required for publishing to GitHub Packages

jobs:
  build-runtime:
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        include:
          # Define OS-specific variables for naming
          - os: ubuntu-latest
            os_name: linux
            archive_ext: tar.gz
          - os: macos-latest
            os_name: macos
            archive_ext: tar.gz
          - os: windows-latest
            os_name: windows
            archive_ext: zip

    steps:
      # 1. Check out the repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Set Java and version parameters
      - name: Set Java and version parameters
        shell: bash
        run: |
          # Set Java version (from input or default)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            JAVA_VERSION="${{ inputs.java_version }}"
            VERSION="${{ inputs.tag_version }}"
          else
            JAVA_VERSION="21.0.5+11"
            VERSION="${GITHUB_REF_NAME#v}"
          fi
          echo "JAVA_VERSION=$JAVA_VERSION" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Using Java version: $JAVA_VERSION"
          echo "Using runtime version: $VERSION"

      # 3. Detect architecture
      - name: Detect architecture
        shell: bash
        run: |
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            ARCH="x64"
          elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
            ARCH="aarch64"
          fi
          echo "ARCH=$ARCH" >> $GITHUB_ENV
          echo "Detected architecture: $ARCH"

      # 4. Set up JDK 21 using actions/setup-java with JavaFX support
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: liberica
          java-version: 21
          java-package: jdk+fx

      # 5. Verify JAVA_HOME and add to PATH
      - name: Verify JAVA_HOME and add to PATH
        shell: bash
        run: |
          echo "JAVA_HOME: $JAVA_HOME"
          if [ -z "$JAVA_HOME" ]; then
            echo "ERROR: JAVA_HOME is not set"
            exit 1
          fi
          if [ ! -d "$JAVA_HOME/bin" ]; then
            echo "ERROR: $JAVA_HOME/bin not found"
            echo "Contents of $JAVA_HOME:" || true
            ls -la "$JAVA_HOME" || true
            exit 1
          fi
          # Check that jlink is executable
          if [ ! -x "$JAVA_HOME/bin/jlink" ]; then
            echo "ERROR: jlink not found or not executable at $JAVA_HOME/bin/jlink"
            ls -la "$JAVA_HOME/bin" || true
            exit 1
          fi
          # Check that jmods directory exists
          if [ ! -d "$JAVA_HOME/jmods" ]; then
            echo "ERROR: jmods directory not found at $JAVA_HOME/jmods"
            ls -la "$JAVA_HOME" || true
            exit 1
          fi
          echo "jlink path: $JAVA_HOME/bin/jlink"
          echo "jmods path: $JAVA_HOME/jmods"
          echo "$JAVA_HOME/bin" >> $GITHUB_PATH
          "$JAVA_HOME/bin/java" -version
          "$JAVA_HOME/bin/jlink" --version

      # 6. Create custom JRE runtime using jlink
      #    This creates a minimal runtime with JavaFX modules included
      - name: Build custom JRE with jlink (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          cat <<'BASH' > /tmp/new_unix_jlink.sh
          set -euo pipefail
          # Ensure jlink binary and jmods exist
          echo "PWD: $(pwd)"
          echo "GITHUB_WORKSPACE: ${GITHUB_WORKSPACE:-unset}"
          OUTPUT_DIR="${GITHUB_WORKSPACE:-$PWD}/build/runtime"
          echo "Output dir: $OUTPUT_DIR"

          if [ ! -x "${JAVA_HOME}/bin/jlink" ]; then
            echo "ERROR: jlink not found or not executable at ${JAVA_HOME}/bin/jlink"
            ls -la "${JAVA_HOME}/bin" || true
            exit 1
          fi

          if [ ! -d "${JAVA_HOME}/jmods" ]; then
            echo "ERROR: jmods directory not found at ${JAVA_HOME}/jmods"
            ls -la "${JAVA_HOME}" || true
            exit 1
          fi

          # Remove any previous output but DO NOT create the directory: jlink requires non-existing output dir
          rm -rf "$OUTPUT_DIR"

          # Debug list parent dir
          ls -la "$(dirname "$OUTPUT_DIR")" || true
          [ -e "$OUTPUT_DIR" ] && { echo "ERROR: $OUTPUT_DIR still exists"; exit 1; } || echo "$OUTPUT_DIR does not exist, OK"

          # Run jlink (jlink will create the output directory)
          set -x
          "$JAVA_HOME/bin/jlink" \
            --module-path "$JAVA_HOME/jmods" \
            --add-modules java.base,java.logging,java.desktop,java.sql,java.naming,java.management,java.xml,java.prefs,javafx.controls,javafx.fxml,javafx.graphics,javafx.swing,javafx.media \
            --output "$OUTPUT_DIR" \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --compress=2
          set +x

          echo "Custom JRE created successfully"
          ls -la "$OUTPUT_DIR"
          BASH

          /bin/bash /tmp/new_unix_jlink.sh

      - name: Build custom JRE with jlink (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          # PowerShell script (exact content)
          $ErrorActionPreference = 'Stop'
          Write-Output "PWD: $(Get-Location)"
          Write-Output "GITHUB_WORKSPACE: $env:GITHUB_WORKSPACE"
          $outputDir = Join-Path $env:GITHUB_WORKSPACE 'build/runtime'
          Write-Output "Output dir: $outputDir"

          if (-not (Test-Path (Join-Path $env:JAVA_HOME 'bin\jlink.exe'))) {
            Write-Error "ERROR: jlink.exe not found at $env:JAVA_HOME\bin\jlink.exe"
            Get-ChildItem "$env:JAVA_HOME\bin" -Force -ErrorAction SilentlyContinue | Format-List
            exit 1
          }

          if (-not (Test-Path (Join-Path $env:JAVA_HOME 'jmods'))) {
            Write-Error "ERROR: jmods directory not found at $env:JAVA_HOME\jmods"
            Get-ChildItem $env:JAVA_HOME -Force -ErrorAction SilentlyContinue | Format-List
            exit 1
          }

          if (Test-Path $outputDir) { Remove-Item $outputDir -Recurse -Force }

          Get-ChildItem (Split-Path $outputDir -Parent) -Force -ErrorAction SilentlyContinue | Format-List

          if (Test-Path $outputDir) { Write-Error "$outputDir still exists"; exit 1 } else { Write-Output "$outputDir does not exist, OK" }

          # Run jlink (jlink will create the output directory)
          & "$env:JAVA_HOME\bin\jlink.exe" `
            --module-path "$env:JAVA_HOME\jmods" `
            --add-modules java.base,java.logging,java.desktop,java.sql,java.naming,java.management,java.xml,java.prefs,javafx.controls,javafx.fxml,javafx.graphics,javafx.swing,javafx.media `
            --output $outputDir `
            --strip-debug `
            --no-header-files `
            --no-man-pages `
            --compress=2

          Write-Output "Custom JRE created successfully"
          Get-ChildItem $outputDir -Force | Format-List

      # 7. Create archive name based on OS, architecture, and version
      - name: Set archive name
        shell: bash
        run: |
          ARCHIVE_NAME="efa-jre-${{ env.VERSION }}-${{ matrix.os_name }}-${{ env.ARCH }}.${{ matrix.archive_ext }}"
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV
          echo "Archive will be named: $ARCHIVE_NAME"

      # 8. Archive the runtime (tar.gz for Linux/macOS, zip for Windows)
      - name: Archive runtime (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          cd build
          tar -czf "../${{ env.ARCHIVE_NAME }}" runtime
          cd ..
          echo "Archive created: ${{ env.ARCHIVE_NAME }}"
          ls -lh "${{ env.ARCHIVE_NAME }}"

      - name: Archive runtime (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          cd build
          Compress-Archive -Path runtime -DestinationPath "..\${{ env.ARCHIVE_NAME }}"
          cd ..
          echo "Archive created: ${{ env.ARCHIVE_NAME }}"
          Get-Item "${{ env.ARCHIVE_NAME }}" | Format-List

      # 9. Generate SHA-256 checksum for the archive
      - name: Generate SHA-256 checksum
        shell: bash
        run: |
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            sha256sum "${{ env.ARCHIVE_NAME }}" > "${{ env.ARCHIVE_NAME }}.sha256"
          else
            shasum -a 256 "${{ env.ARCHIVE_NAME }}" > "${{ env.ARCHIVE_NAME }}.sha256"
          fi
          cat "${{ env.ARCHIVE_NAME }}.sha256"

      # 10. Upload artifact to GitHub Actions (for workflow verification)
      - name: Upload runtime archive as artifact
        uses: actions/upload-artifact@v4
        with:
          name: jre-${{ matrix.os_name }}-${{ env.ARCH }}
          path: |
            ${{ env.ARCHIVE_NAME }}
            ${{ env.ARCHIVE_NAME }}.sha256

      # 11. Publish to GitHub Packages as a generic package
      #     GitHub Packages supports generic packages via the API
      #     We'll use the GitHub CLI (gh) which is pre-installed on runners
      - name: Publish to GitHub Packages
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Package details
          PACKAGE_NAME="${{ github.repository }}-jre"
          PACKAGE_VERSION="${{ env.VERSION }}"

          echo "Publishing package: $PACKAGE_NAME"
          echo "Version: $PACKAGE_VERSION"
          echo "File: ${{ env.ARCHIVE_NAME }}"

          # Upload the archive to GitHub Packages using the API
          # GitHub Packages requires uploading to a specific endpoint
          # Format: https://maven.pkg.github.com/OWNER/REPO

          # For generic packages, we can use the Releases API or Maven registry
          # Since we're already creating a release workflow, we'll upload to releases
          # For true generic package support, consider using a Maven-compatible approach
          # or the Container registry with additional metadata

          # Create a release if it doesn't exist
          if ! gh release view "v${{ env.VERSION }}" >/dev/null 2>&1; then
            gh release create "v${{ env.VERSION }}" \
              --title "Release v${{ env.VERSION }}" \
              --notes "Custom JRE runtime images for version ${{ env.VERSION }}" \
              --draft=false \
              --prerelease=false || true
          fi

          # Upload the archive to the release
          gh release upload "v${{ env.VERSION }}" \
            "${{ env.ARCHIVE_NAME }}" \
            "${{ env.ARCHIVE_NAME }}.sha256" \
            --clobber

      # 12. Add download instructions as a comment
      - name: Display download instructions
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          cat << 'EOF'

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          ğŸ“¦ JRE Runtime Package Published Successfully!
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          To download the runtime packages, use one of these methods:

          1ï¸âƒ£  Using GitHub CLI (gh):
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          gh release download v${{ env.VERSION }} \
            --repo ${{ github.repository }} \
            --pattern "efa-jre-*"

          2ï¸âƒ£  Using curl (example for Linux x64):
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          curl -L -o efa-jre.tar.gz \
            "https://github.com/${{ github.repository }}/releases/download/v${{ env.VERSION }}/efa-jre-${{ env.VERSION }}-linux-x64.tar.gz"

          3ï¸âƒ£  Direct browser download:
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          https://github.com/${{ github.repository }}/releases/tag/v${{ env.VERSION }}

          Available packages:
            â€¢ efa-jre-${{ env.VERSION }}-linux-x64.tar.gz
            â€¢ efa-jre-${{ env.VERSION }}-macos-<arch>.tar.gz
            â€¢ efa-jre-${{ env.VERSION }}-windows-x64.zip

          Each package includes a .sha256 checksum file for verification.
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          EOF
